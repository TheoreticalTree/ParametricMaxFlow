// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gtfs-realtime-OVapi.proto

#ifndef PROTOBUF_gtfs_2drealtime_2dOVapi_2eproto__INCLUDED
#define PROTOBUF_gtfs_2drealtime_2dOVapi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "gtfs-realtime.pb.h"
// @@protoc_insertion_point(includes)
namespace transit_realtime {
class Alert;
class AlertDefaultTypeInternal;
extern AlertDefaultTypeInternal _Alert_default_instance_;
class EntitySelector;
class EntitySelectorDefaultTypeInternal;
extern EntitySelectorDefaultTypeInternal _EntitySelector_default_instance_;
class FeedEntity;
class FeedEntityDefaultTypeInternal;
extern FeedEntityDefaultTypeInternal _FeedEntity_default_instance_;
class FeedHeader;
class FeedHeaderDefaultTypeInternal;
extern FeedHeaderDefaultTypeInternal _FeedHeader_default_instance_;
class FeedMessage;
class FeedMessageDefaultTypeInternal;
extern FeedMessageDefaultTypeInternal _FeedMessage_default_instance_;
class OVapiStopTimeUpdate;
class OVapiStopTimeUpdateDefaultTypeInternal;
extern OVapiStopTimeUpdateDefaultTypeInternal _OVapiStopTimeUpdate_default_instance_;
class OVapiTripDescriptor;
class OVapiTripDescriptorDefaultTypeInternal;
extern OVapiTripDescriptorDefaultTypeInternal _OVapiTripDescriptor_default_instance_;
class OVapiTripUpdate;
class OVapiTripUpdateDefaultTypeInternal;
extern OVapiTripUpdateDefaultTypeInternal _OVapiTripUpdate_default_instance_;
class OVapiVehicleDescriptor;
class OVapiVehicleDescriptorDefaultTypeInternal;
extern OVapiVehicleDescriptorDefaultTypeInternal _OVapiVehicleDescriptor_default_instance_;
class OVapiVehiclePosition;
class OVapiVehiclePositionDefaultTypeInternal;
extern OVapiVehiclePositionDefaultTypeInternal _OVapiVehiclePosition_default_instance_;
class Position;
class PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class TimeRange;
class TimeRangeDefaultTypeInternal;
extern TimeRangeDefaultTypeInternal _TimeRange_default_instance_;
class TranslatedString;
class TranslatedStringDefaultTypeInternal;
extern TranslatedStringDefaultTypeInternal _TranslatedString_default_instance_;
class TranslatedString_Translation;
class TranslatedString_TranslationDefaultTypeInternal;
extern TranslatedString_TranslationDefaultTypeInternal _TranslatedString_Translation_default_instance_;
class TripDescriptor;
class TripDescriptorDefaultTypeInternal;
extern TripDescriptorDefaultTypeInternal _TripDescriptor_default_instance_;
class TripUpdate;
class TripUpdateDefaultTypeInternal;
extern TripUpdateDefaultTypeInternal _TripUpdate_default_instance_;
class TripUpdate_StopTimeEvent;
class TripUpdate_StopTimeEventDefaultTypeInternal;
extern TripUpdate_StopTimeEventDefaultTypeInternal _TripUpdate_StopTimeEvent_default_instance_;
class TripUpdate_StopTimeUpdate;
class TripUpdate_StopTimeUpdateDefaultTypeInternal;
extern TripUpdate_StopTimeUpdateDefaultTypeInternal _TripUpdate_StopTimeUpdate_default_instance_;
class VehicleDescriptor;
class VehicleDescriptorDefaultTypeInternal;
extern VehicleDescriptorDefaultTypeInternal _VehicleDescriptor_default_instance_;
class VehiclePosition;
class VehiclePositionDefaultTypeInternal;
extern VehiclePositionDefaultTypeInternal _VehiclePosition_default_instance_;
}  // namespace transit_realtime

namespace transit_realtime {

namespace protobuf_gtfs_2drealtime_2dOVapi_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_gtfs_2drealtime_2dOVapi_2eproto

// ===================================================================

class OVapiTripDescriptor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.OVapiTripDescriptor) */ {
 public:
  OVapiTripDescriptor();
  virtual ~OVapiTripDescriptor();

  OVapiTripDescriptor(const OVapiTripDescriptor& from);

  inline OVapiTripDescriptor& operator=(const OVapiTripDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OVapiTripDescriptor& default_instance();

  static inline const OVapiTripDescriptor* internal_default_instance() {
    return reinterpret_cast<const OVapiTripDescriptor*>(
               &_OVapiTripDescriptor_default_instance_);
  }

  void Swap(OVapiTripDescriptor* other);

  // implements Message ----------------------------------------------

  inline OVapiTripDescriptor* New() const PROTOBUF_FINAL { return New(NULL); }

  OVapiTripDescriptor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OVapiTripDescriptor& from);
  void MergeFrom(const OVapiTripDescriptor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OVapiTripDescriptor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string realtime_trip_id = 1;
  bool has_realtime_trip_id() const;
  void clear_realtime_trip_id();
  static const int kRealtimeTripIdFieldNumber = 1;
  const ::std::string& realtime_trip_id() const;
  void set_realtime_trip_id(const ::std::string& value);
  #if LANG_CXX11
  void set_realtime_trip_id(::std::string&& value);
  #endif
  void set_realtime_trip_id(const char* value);
  void set_realtime_trip_id(const char* value, size_t size);
  ::std::string* mutable_realtime_trip_id();
  ::std::string* release_realtime_trip_id();
  void set_allocated_realtime_trip_id(::std::string* realtime_trip_id);

  // optional string trip_short_name = 2;
  bool has_trip_short_name() const;
  void clear_trip_short_name();
  static const int kTripShortNameFieldNumber = 2;
  const ::std::string& trip_short_name() const;
  void set_trip_short_name(const ::std::string& value);
  #if LANG_CXX11
  void set_trip_short_name(::std::string&& value);
  #endif
  void set_trip_short_name(const char* value);
  void set_trip_short_name(const char* value, size_t size);
  ::std::string* mutable_trip_short_name();
  ::std::string* release_trip_short_name();
  void set_allocated_trip_short_name(::std::string* trip_short_name);

  // optional string commercial_mode_id = 3;
  bool has_commercial_mode_id() const;
  void clear_commercial_mode_id();
  static const int kCommercialModeIdFieldNumber = 3;
  const ::std::string& commercial_mode_id() const;
  void set_commercial_mode_id(const ::std::string& value);
  #if LANG_CXX11
  void set_commercial_mode_id(::std::string&& value);
  #endif
  void set_commercial_mode_id(const char* value);
  void set_commercial_mode_id(const char* value, size_t size);
  ::std::string* mutable_commercial_mode_id();
  ::std::string* release_commercial_mode_id();
  void set_allocated_commercial_mode_id(::std::string* commercial_mode_id);

  // @@protoc_insertion_point(class_scope:transit_realtime.OVapiTripDescriptor)
 private:
  void set_has_realtime_trip_id();
  void clear_has_realtime_trip_id();
  void set_has_trip_short_name();
  void clear_has_trip_short_name();
  void set_has_commercial_mode_id();
  void clear_has_commercial_mode_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr realtime_trip_id_;
  ::google::protobuf::internal::ArenaStringPtr trip_short_name_;
  ::google::protobuf::internal::ArenaStringPtr commercial_mode_id_;
  friend struct  protobuf_gtfs_2drealtime_2dOVapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OVapiVehiclePosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.OVapiVehiclePosition) */ {
 public:
  OVapiVehiclePosition();
  virtual ~OVapiVehiclePosition();

  OVapiVehiclePosition(const OVapiVehiclePosition& from);

  inline OVapiVehiclePosition& operator=(const OVapiVehiclePosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OVapiVehiclePosition& default_instance();

  static inline const OVapiVehiclePosition* internal_default_instance() {
    return reinterpret_cast<const OVapiVehiclePosition*>(
               &_OVapiVehiclePosition_default_instance_);
  }

  void Swap(OVapiVehiclePosition* other);

  // implements Message ----------------------------------------------

  inline OVapiVehiclePosition* New() const PROTOBUF_FINAL { return New(NULL); }

  OVapiVehiclePosition* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OVapiVehiclePosition& from);
  void MergeFrom(const OVapiVehiclePosition& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OVapiVehiclePosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 delay = 1;
  bool has_delay() const;
  void clear_delay();
  static const int kDelayFieldNumber = 1;
  ::google::protobuf::int32 delay() const;
  void set_delay(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:transit_realtime.OVapiVehiclePosition)
 private:
  void set_has_delay();
  void clear_has_delay();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 delay_;
  friend struct  protobuf_gtfs_2drealtime_2dOVapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OVapiTripUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.OVapiTripUpdate) */ {
 public:
  OVapiTripUpdate();
  virtual ~OVapiTripUpdate();

  OVapiTripUpdate(const OVapiTripUpdate& from);

  inline OVapiTripUpdate& operator=(const OVapiTripUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OVapiTripUpdate& default_instance();

  static inline const OVapiTripUpdate* internal_default_instance() {
    return reinterpret_cast<const OVapiTripUpdate*>(
               &_OVapiTripUpdate_default_instance_);
  }

  void Swap(OVapiTripUpdate* other);

  // implements Message ----------------------------------------------

  inline OVapiTripUpdate* New() const PROTOBUF_FINAL { return New(NULL); }

  OVapiTripUpdate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OVapiTripUpdate& from);
  void MergeFrom(const OVapiTripUpdate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OVapiTripUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string trip_headsign = 1;
  bool has_trip_headsign() const;
  void clear_trip_headsign();
  static const int kTripHeadsignFieldNumber = 1;
  const ::std::string& trip_headsign() const;
  void set_trip_headsign(const ::std::string& value);
  #if LANG_CXX11
  void set_trip_headsign(::std::string&& value);
  #endif
  void set_trip_headsign(const char* value);
  void set_trip_headsign(const char* value, size_t size);
  ::std::string* mutable_trip_headsign();
  ::std::string* release_trip_headsign();
  void set_allocated_trip_headsign(::std::string* trip_headsign);

  // @@protoc_insertion_point(class_scope:transit_realtime.OVapiTripUpdate)
 private:
  void set_has_trip_headsign();
  void clear_has_trip_headsign();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr trip_headsign_;
  friend struct  protobuf_gtfs_2drealtime_2dOVapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OVapiStopTimeUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.OVapiStopTimeUpdate) */ {
 public:
  OVapiStopTimeUpdate();
  virtual ~OVapiStopTimeUpdate();

  OVapiStopTimeUpdate(const OVapiStopTimeUpdate& from);

  inline OVapiStopTimeUpdate& operator=(const OVapiStopTimeUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OVapiStopTimeUpdate& default_instance();

  static inline const OVapiStopTimeUpdate* internal_default_instance() {
    return reinterpret_cast<const OVapiStopTimeUpdate*>(
               &_OVapiStopTimeUpdate_default_instance_);
  }

  void Swap(OVapiStopTimeUpdate* other);

  // implements Message ----------------------------------------------

  inline OVapiStopTimeUpdate* New() const PROTOBUF_FINAL { return New(NULL); }

  OVapiStopTimeUpdate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OVapiStopTimeUpdate& from);
  void MergeFrom(const OVapiStopTimeUpdate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OVapiStopTimeUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string stop_headsign = 1;
  bool has_stop_headsign() const;
  void clear_stop_headsign();
  static const int kStopHeadsignFieldNumber = 1;
  const ::std::string& stop_headsign() const;
  void set_stop_headsign(const ::std::string& value);
  #if LANG_CXX11
  void set_stop_headsign(::std::string&& value);
  #endif
  void set_stop_headsign(const char* value);
  void set_stop_headsign(const char* value, size_t size);
  ::std::string* mutable_stop_headsign();
  ::std::string* release_stop_headsign();
  void set_allocated_stop_headsign(::std::string* stop_headsign);

  // optional string scheduled_track = 2;
  bool has_scheduled_track() const;
  void clear_scheduled_track();
  static const int kScheduledTrackFieldNumber = 2;
  const ::std::string& scheduled_track() const;
  void set_scheduled_track(const ::std::string& value);
  #if LANG_CXX11
  void set_scheduled_track(::std::string&& value);
  #endif
  void set_scheduled_track(const char* value);
  void set_scheduled_track(const char* value, size_t size);
  ::std::string* mutable_scheduled_track();
  ::std::string* release_scheduled_track();
  void set_allocated_scheduled_track(::std::string* scheduled_track);

  // optional string actual_track = 3;
  bool has_actual_track() const;
  void clear_actual_track();
  static const int kActualTrackFieldNumber = 3;
  const ::std::string& actual_track() const;
  void set_actual_track(const ::std::string& value);
  #if LANG_CXX11
  void set_actual_track(::std::string&& value);
  #endif
  void set_actual_track(const char* value);
  void set_actual_track(const char* value, size_t size);
  ::std::string* mutable_actual_track();
  ::std::string* release_actual_track();
  void set_allocated_actual_track(::std::string* actual_track);

  // optional string station_id = 4;
  bool has_station_id() const;
  void clear_station_id();
  static const int kStationIdFieldNumber = 4;
  const ::std::string& station_id() const;
  void set_station_id(const ::std::string& value);
  #if LANG_CXX11
  void set_station_id(::std::string&& value);
  #endif
  void set_station_id(const char* value);
  void set_station_id(const char* value, size_t size);
  ::std::string* mutable_station_id();
  ::std::string* release_station_id();
  void set_allocated_station_id(::std::string* station_id);

  // @@protoc_insertion_point(class_scope:transit_realtime.OVapiStopTimeUpdate)
 private:
  void set_has_stop_headsign();
  void clear_has_stop_headsign();
  void set_has_scheduled_track();
  void clear_has_scheduled_track();
  void set_has_actual_track();
  void clear_has_actual_track();
  void set_has_station_id();
  void clear_has_station_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr stop_headsign_;
  ::google::protobuf::internal::ArenaStringPtr scheduled_track_;
  ::google::protobuf::internal::ArenaStringPtr actual_track_;
  ::google::protobuf::internal::ArenaStringPtr station_id_;
  friend struct  protobuf_gtfs_2drealtime_2dOVapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OVapiVehicleDescriptor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.OVapiVehicleDescriptor) */ {
 public:
  OVapiVehicleDescriptor();
  virtual ~OVapiVehicleDescriptor();

  OVapiVehicleDescriptor(const OVapiVehicleDescriptor& from);

  inline OVapiVehicleDescriptor& operator=(const OVapiVehicleDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OVapiVehicleDescriptor& default_instance();

  static inline const OVapiVehicleDescriptor* internal_default_instance() {
    return reinterpret_cast<const OVapiVehicleDescriptor*>(
               &_OVapiVehicleDescriptor_default_instance_);
  }

  void Swap(OVapiVehicleDescriptor* other);

  // implements Message ----------------------------------------------

  inline OVapiVehicleDescriptor* New() const PROTOBUF_FINAL { return New(NULL); }

  OVapiVehicleDescriptor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OVapiVehicleDescriptor& from);
  void MergeFrom(const OVapiVehicleDescriptor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OVapiVehicleDescriptor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string vehicle_type = 2;
  bool has_vehicle_type() const;
  void clear_vehicle_type();
  static const int kVehicleTypeFieldNumber = 2;
  const ::std::string& vehicle_type() const;
  void set_vehicle_type(const ::std::string& value);
  #if LANG_CXX11
  void set_vehicle_type(::std::string&& value);
  #endif
  void set_vehicle_type(const char* value);
  void set_vehicle_type(const char* value, size_t size);
  ::std::string* mutable_vehicle_type();
  ::std::string* release_vehicle_type();
  void set_allocated_vehicle_type(::std::string* vehicle_type);

  // optional string vehicle_headsign = 3;
  bool has_vehicle_headsign() const;
  void clear_vehicle_headsign();
  static const int kVehicleHeadsignFieldNumber = 3;
  const ::std::string& vehicle_headsign() const;
  void set_vehicle_headsign(const ::std::string& value);
  #if LANG_CXX11
  void set_vehicle_headsign(::std::string&& value);
  #endif
  void set_vehicle_headsign(const char* value);
  void set_vehicle_headsign(const char* value, size_t size);
  ::std::string* mutable_vehicle_headsign();
  ::std::string* release_vehicle_headsign();
  void set_allocated_vehicle_headsign(::std::string* vehicle_headsign);

  // optional bool wheelchair_accessible = 1;
  bool has_wheelchair_accessible() const;
  void clear_wheelchair_accessible();
  static const int kWheelchairAccessibleFieldNumber = 1;
  bool wheelchair_accessible() const;
  void set_wheelchair_accessible(bool value);

  // @@protoc_insertion_point(class_scope:transit_realtime.OVapiVehicleDescriptor)
 private:
  void set_has_wheelchair_accessible();
  void clear_has_wheelchair_accessible();
  void set_has_vehicle_type();
  void clear_has_vehicle_type();
  void set_has_vehicle_headsign();
  void clear_has_vehicle_headsign();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr vehicle_type_;
  ::google::protobuf::internal::ArenaStringPtr vehicle_headsign_;
  bool wheelchair_accessible_;
  friend struct  protobuf_gtfs_2drealtime_2dOVapi_2eproto::TableStruct;
};
// ===================================================================

static const int kOvapiTripdescriptorFieldNumber = 1003;
extern ::google::protobuf::internal::ExtensionIdentifier< ::transit_realtime::TripDescriptor,
    ::google::protobuf::internal::MessageTypeTraits< ::transit_realtime::OVapiTripDescriptor >, 11, false >
  ovapi_tripdescriptor;
static const int kOvapiVehiclePositionFieldNumber = 1003;
extern ::google::protobuf::internal::ExtensionIdentifier< ::transit_realtime::VehiclePosition,
    ::google::protobuf::internal::MessageTypeTraits< ::transit_realtime::OVapiVehiclePosition >, 11, false >
  ovapi_vehicle_position;
static const int kOvapiTripUpdateFieldNumber = 1003;
extern ::google::protobuf::internal::ExtensionIdentifier< ::transit_realtime::TripUpdate,
    ::google::protobuf::internal::MessageTypeTraits< ::transit_realtime::OVapiTripUpdate >, 11, false >
  ovapi_trip_update;
static const int kOvapiStopTimeUpdateFieldNumber = 1003;
extern ::google::protobuf::internal::ExtensionIdentifier< ::transit_realtime::TripUpdate_StopTimeUpdate,
    ::google::protobuf::internal::MessageTypeTraits< ::transit_realtime::OVapiStopTimeUpdate >, 11, false >
  ovapi_stop_time_update;
static const int kOvapiVehicleDescriptorFieldNumber = 1003;
extern ::google::protobuf::internal::ExtensionIdentifier< ::transit_realtime::VehicleDescriptor,
    ::google::protobuf::internal::MessageTypeTraits< ::transit_realtime::OVapiVehicleDescriptor >, 11, false >
  ovapi_vehicle_descriptor;

// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// OVapiTripDescriptor

// optional string realtime_trip_id = 1;
inline bool OVapiTripDescriptor::has_realtime_trip_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OVapiTripDescriptor::set_has_realtime_trip_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OVapiTripDescriptor::clear_has_realtime_trip_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OVapiTripDescriptor::clear_realtime_trip_id() {
  realtime_trip_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_realtime_trip_id();
}
inline const ::std::string& OVapiTripDescriptor::realtime_trip_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.OVapiTripDescriptor.realtime_trip_id)
  return realtime_trip_id_.GetNoArena();
}
inline void OVapiTripDescriptor::set_realtime_trip_id(const ::std::string& value) {
  set_has_realtime_trip_id();
  realtime_trip_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.OVapiTripDescriptor.realtime_trip_id)
}
#if LANG_CXX11
inline void OVapiTripDescriptor::set_realtime_trip_id(::std::string&& value) {
  set_has_realtime_trip_id();
  realtime_trip_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transit_realtime.OVapiTripDescriptor.realtime_trip_id)
}
#endif
inline void OVapiTripDescriptor::set_realtime_trip_id(const char* value) {
  set_has_realtime_trip_id();
  realtime_trip_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.OVapiTripDescriptor.realtime_trip_id)
}
inline void OVapiTripDescriptor::set_realtime_trip_id(const char* value, size_t size) {
  set_has_realtime_trip_id();
  realtime_trip_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.OVapiTripDescriptor.realtime_trip_id)
}
inline ::std::string* OVapiTripDescriptor::mutable_realtime_trip_id() {
  set_has_realtime_trip_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.OVapiTripDescriptor.realtime_trip_id)
  return realtime_trip_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OVapiTripDescriptor::release_realtime_trip_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.OVapiTripDescriptor.realtime_trip_id)
  clear_has_realtime_trip_id();
  return realtime_trip_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OVapiTripDescriptor::set_allocated_realtime_trip_id(::std::string* realtime_trip_id) {
  if (realtime_trip_id != NULL) {
    set_has_realtime_trip_id();
  } else {
    clear_has_realtime_trip_id();
  }
  realtime_trip_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), realtime_trip_id);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.OVapiTripDescriptor.realtime_trip_id)
}

// optional string trip_short_name = 2;
inline bool OVapiTripDescriptor::has_trip_short_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OVapiTripDescriptor::set_has_trip_short_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OVapiTripDescriptor::clear_has_trip_short_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OVapiTripDescriptor::clear_trip_short_name() {
  trip_short_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trip_short_name();
}
inline const ::std::string& OVapiTripDescriptor::trip_short_name() const {
  // @@protoc_insertion_point(field_get:transit_realtime.OVapiTripDescriptor.trip_short_name)
  return trip_short_name_.GetNoArena();
}
inline void OVapiTripDescriptor::set_trip_short_name(const ::std::string& value) {
  set_has_trip_short_name();
  trip_short_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.OVapiTripDescriptor.trip_short_name)
}
#if LANG_CXX11
inline void OVapiTripDescriptor::set_trip_short_name(::std::string&& value) {
  set_has_trip_short_name();
  trip_short_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transit_realtime.OVapiTripDescriptor.trip_short_name)
}
#endif
inline void OVapiTripDescriptor::set_trip_short_name(const char* value) {
  set_has_trip_short_name();
  trip_short_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.OVapiTripDescriptor.trip_short_name)
}
inline void OVapiTripDescriptor::set_trip_short_name(const char* value, size_t size) {
  set_has_trip_short_name();
  trip_short_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.OVapiTripDescriptor.trip_short_name)
}
inline ::std::string* OVapiTripDescriptor::mutable_trip_short_name() {
  set_has_trip_short_name();
  // @@protoc_insertion_point(field_mutable:transit_realtime.OVapiTripDescriptor.trip_short_name)
  return trip_short_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OVapiTripDescriptor::release_trip_short_name() {
  // @@protoc_insertion_point(field_release:transit_realtime.OVapiTripDescriptor.trip_short_name)
  clear_has_trip_short_name();
  return trip_short_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OVapiTripDescriptor::set_allocated_trip_short_name(::std::string* trip_short_name) {
  if (trip_short_name != NULL) {
    set_has_trip_short_name();
  } else {
    clear_has_trip_short_name();
  }
  trip_short_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trip_short_name);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.OVapiTripDescriptor.trip_short_name)
}

// optional string commercial_mode_id = 3;
inline bool OVapiTripDescriptor::has_commercial_mode_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OVapiTripDescriptor::set_has_commercial_mode_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OVapiTripDescriptor::clear_has_commercial_mode_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OVapiTripDescriptor::clear_commercial_mode_id() {
  commercial_mode_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_commercial_mode_id();
}
inline const ::std::string& OVapiTripDescriptor::commercial_mode_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.OVapiTripDescriptor.commercial_mode_id)
  return commercial_mode_id_.GetNoArena();
}
inline void OVapiTripDescriptor::set_commercial_mode_id(const ::std::string& value) {
  set_has_commercial_mode_id();
  commercial_mode_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.OVapiTripDescriptor.commercial_mode_id)
}
#if LANG_CXX11
inline void OVapiTripDescriptor::set_commercial_mode_id(::std::string&& value) {
  set_has_commercial_mode_id();
  commercial_mode_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transit_realtime.OVapiTripDescriptor.commercial_mode_id)
}
#endif
inline void OVapiTripDescriptor::set_commercial_mode_id(const char* value) {
  set_has_commercial_mode_id();
  commercial_mode_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.OVapiTripDescriptor.commercial_mode_id)
}
inline void OVapiTripDescriptor::set_commercial_mode_id(const char* value, size_t size) {
  set_has_commercial_mode_id();
  commercial_mode_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.OVapiTripDescriptor.commercial_mode_id)
}
inline ::std::string* OVapiTripDescriptor::mutable_commercial_mode_id() {
  set_has_commercial_mode_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.OVapiTripDescriptor.commercial_mode_id)
  return commercial_mode_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OVapiTripDescriptor::release_commercial_mode_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.OVapiTripDescriptor.commercial_mode_id)
  clear_has_commercial_mode_id();
  return commercial_mode_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OVapiTripDescriptor::set_allocated_commercial_mode_id(::std::string* commercial_mode_id) {
  if (commercial_mode_id != NULL) {
    set_has_commercial_mode_id();
  } else {
    clear_has_commercial_mode_id();
  }
  commercial_mode_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), commercial_mode_id);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.OVapiTripDescriptor.commercial_mode_id)
}

// -------------------------------------------------------------------

// OVapiVehiclePosition

// optional int32 delay = 1;
inline bool OVapiVehiclePosition::has_delay() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OVapiVehiclePosition::set_has_delay() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OVapiVehiclePosition::clear_has_delay() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OVapiVehiclePosition::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline ::google::protobuf::int32 OVapiVehiclePosition::delay() const {
  // @@protoc_insertion_point(field_get:transit_realtime.OVapiVehiclePosition.delay)
  return delay_;
}
inline void OVapiVehiclePosition::set_delay(::google::protobuf::int32 value) {
  set_has_delay();
  delay_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.OVapiVehiclePosition.delay)
}

// -------------------------------------------------------------------

// OVapiTripUpdate

// optional string trip_headsign = 1;
inline bool OVapiTripUpdate::has_trip_headsign() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OVapiTripUpdate::set_has_trip_headsign() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OVapiTripUpdate::clear_has_trip_headsign() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OVapiTripUpdate::clear_trip_headsign() {
  trip_headsign_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trip_headsign();
}
inline const ::std::string& OVapiTripUpdate::trip_headsign() const {
  // @@protoc_insertion_point(field_get:transit_realtime.OVapiTripUpdate.trip_headsign)
  return trip_headsign_.GetNoArena();
}
inline void OVapiTripUpdate::set_trip_headsign(const ::std::string& value) {
  set_has_trip_headsign();
  trip_headsign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.OVapiTripUpdate.trip_headsign)
}
#if LANG_CXX11
inline void OVapiTripUpdate::set_trip_headsign(::std::string&& value) {
  set_has_trip_headsign();
  trip_headsign_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transit_realtime.OVapiTripUpdate.trip_headsign)
}
#endif
inline void OVapiTripUpdate::set_trip_headsign(const char* value) {
  set_has_trip_headsign();
  trip_headsign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.OVapiTripUpdate.trip_headsign)
}
inline void OVapiTripUpdate::set_trip_headsign(const char* value, size_t size) {
  set_has_trip_headsign();
  trip_headsign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.OVapiTripUpdate.trip_headsign)
}
inline ::std::string* OVapiTripUpdate::mutable_trip_headsign() {
  set_has_trip_headsign();
  // @@protoc_insertion_point(field_mutable:transit_realtime.OVapiTripUpdate.trip_headsign)
  return trip_headsign_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OVapiTripUpdate::release_trip_headsign() {
  // @@protoc_insertion_point(field_release:transit_realtime.OVapiTripUpdate.trip_headsign)
  clear_has_trip_headsign();
  return trip_headsign_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OVapiTripUpdate::set_allocated_trip_headsign(::std::string* trip_headsign) {
  if (trip_headsign != NULL) {
    set_has_trip_headsign();
  } else {
    clear_has_trip_headsign();
  }
  trip_headsign_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trip_headsign);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.OVapiTripUpdate.trip_headsign)
}

// -------------------------------------------------------------------

// OVapiStopTimeUpdate

// optional string stop_headsign = 1;
inline bool OVapiStopTimeUpdate::has_stop_headsign() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OVapiStopTimeUpdate::set_has_stop_headsign() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OVapiStopTimeUpdate::clear_has_stop_headsign() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OVapiStopTimeUpdate::clear_stop_headsign() {
  stop_headsign_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_stop_headsign();
}
inline const ::std::string& OVapiStopTimeUpdate::stop_headsign() const {
  // @@protoc_insertion_point(field_get:transit_realtime.OVapiStopTimeUpdate.stop_headsign)
  return stop_headsign_.GetNoArena();
}
inline void OVapiStopTimeUpdate::set_stop_headsign(const ::std::string& value) {
  set_has_stop_headsign();
  stop_headsign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.OVapiStopTimeUpdate.stop_headsign)
}
#if LANG_CXX11
inline void OVapiStopTimeUpdate::set_stop_headsign(::std::string&& value) {
  set_has_stop_headsign();
  stop_headsign_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transit_realtime.OVapiStopTimeUpdate.stop_headsign)
}
#endif
inline void OVapiStopTimeUpdate::set_stop_headsign(const char* value) {
  set_has_stop_headsign();
  stop_headsign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.OVapiStopTimeUpdate.stop_headsign)
}
inline void OVapiStopTimeUpdate::set_stop_headsign(const char* value, size_t size) {
  set_has_stop_headsign();
  stop_headsign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.OVapiStopTimeUpdate.stop_headsign)
}
inline ::std::string* OVapiStopTimeUpdate::mutable_stop_headsign() {
  set_has_stop_headsign();
  // @@protoc_insertion_point(field_mutable:transit_realtime.OVapiStopTimeUpdate.stop_headsign)
  return stop_headsign_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OVapiStopTimeUpdate::release_stop_headsign() {
  // @@protoc_insertion_point(field_release:transit_realtime.OVapiStopTimeUpdate.stop_headsign)
  clear_has_stop_headsign();
  return stop_headsign_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OVapiStopTimeUpdate::set_allocated_stop_headsign(::std::string* stop_headsign) {
  if (stop_headsign != NULL) {
    set_has_stop_headsign();
  } else {
    clear_has_stop_headsign();
  }
  stop_headsign_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stop_headsign);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.OVapiStopTimeUpdate.stop_headsign)
}

// optional string scheduled_track = 2;
inline bool OVapiStopTimeUpdate::has_scheduled_track() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OVapiStopTimeUpdate::set_has_scheduled_track() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OVapiStopTimeUpdate::clear_has_scheduled_track() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OVapiStopTimeUpdate::clear_scheduled_track() {
  scheduled_track_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_scheduled_track();
}
inline const ::std::string& OVapiStopTimeUpdate::scheduled_track() const {
  // @@protoc_insertion_point(field_get:transit_realtime.OVapiStopTimeUpdate.scheduled_track)
  return scheduled_track_.GetNoArena();
}
inline void OVapiStopTimeUpdate::set_scheduled_track(const ::std::string& value) {
  set_has_scheduled_track();
  scheduled_track_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.OVapiStopTimeUpdate.scheduled_track)
}
#if LANG_CXX11
inline void OVapiStopTimeUpdate::set_scheduled_track(::std::string&& value) {
  set_has_scheduled_track();
  scheduled_track_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transit_realtime.OVapiStopTimeUpdate.scheduled_track)
}
#endif
inline void OVapiStopTimeUpdate::set_scheduled_track(const char* value) {
  set_has_scheduled_track();
  scheduled_track_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.OVapiStopTimeUpdate.scheduled_track)
}
inline void OVapiStopTimeUpdate::set_scheduled_track(const char* value, size_t size) {
  set_has_scheduled_track();
  scheduled_track_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.OVapiStopTimeUpdate.scheduled_track)
}
inline ::std::string* OVapiStopTimeUpdate::mutable_scheduled_track() {
  set_has_scheduled_track();
  // @@protoc_insertion_point(field_mutable:transit_realtime.OVapiStopTimeUpdate.scheduled_track)
  return scheduled_track_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OVapiStopTimeUpdate::release_scheduled_track() {
  // @@protoc_insertion_point(field_release:transit_realtime.OVapiStopTimeUpdate.scheduled_track)
  clear_has_scheduled_track();
  return scheduled_track_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OVapiStopTimeUpdate::set_allocated_scheduled_track(::std::string* scheduled_track) {
  if (scheduled_track != NULL) {
    set_has_scheduled_track();
  } else {
    clear_has_scheduled_track();
  }
  scheduled_track_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scheduled_track);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.OVapiStopTimeUpdate.scheduled_track)
}

// optional string actual_track = 3;
inline bool OVapiStopTimeUpdate::has_actual_track() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OVapiStopTimeUpdate::set_has_actual_track() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OVapiStopTimeUpdate::clear_has_actual_track() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OVapiStopTimeUpdate::clear_actual_track() {
  actual_track_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_actual_track();
}
inline const ::std::string& OVapiStopTimeUpdate::actual_track() const {
  // @@protoc_insertion_point(field_get:transit_realtime.OVapiStopTimeUpdate.actual_track)
  return actual_track_.GetNoArena();
}
inline void OVapiStopTimeUpdate::set_actual_track(const ::std::string& value) {
  set_has_actual_track();
  actual_track_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.OVapiStopTimeUpdate.actual_track)
}
#if LANG_CXX11
inline void OVapiStopTimeUpdate::set_actual_track(::std::string&& value) {
  set_has_actual_track();
  actual_track_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transit_realtime.OVapiStopTimeUpdate.actual_track)
}
#endif
inline void OVapiStopTimeUpdate::set_actual_track(const char* value) {
  set_has_actual_track();
  actual_track_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.OVapiStopTimeUpdate.actual_track)
}
inline void OVapiStopTimeUpdate::set_actual_track(const char* value, size_t size) {
  set_has_actual_track();
  actual_track_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.OVapiStopTimeUpdate.actual_track)
}
inline ::std::string* OVapiStopTimeUpdate::mutable_actual_track() {
  set_has_actual_track();
  // @@protoc_insertion_point(field_mutable:transit_realtime.OVapiStopTimeUpdate.actual_track)
  return actual_track_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OVapiStopTimeUpdate::release_actual_track() {
  // @@protoc_insertion_point(field_release:transit_realtime.OVapiStopTimeUpdate.actual_track)
  clear_has_actual_track();
  return actual_track_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OVapiStopTimeUpdate::set_allocated_actual_track(::std::string* actual_track) {
  if (actual_track != NULL) {
    set_has_actual_track();
  } else {
    clear_has_actual_track();
  }
  actual_track_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), actual_track);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.OVapiStopTimeUpdate.actual_track)
}

// optional string station_id = 4;
inline bool OVapiStopTimeUpdate::has_station_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OVapiStopTimeUpdate::set_has_station_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OVapiStopTimeUpdate::clear_has_station_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OVapiStopTimeUpdate::clear_station_id() {
  station_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_station_id();
}
inline const ::std::string& OVapiStopTimeUpdate::station_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.OVapiStopTimeUpdate.station_id)
  return station_id_.GetNoArena();
}
inline void OVapiStopTimeUpdate::set_station_id(const ::std::string& value) {
  set_has_station_id();
  station_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.OVapiStopTimeUpdate.station_id)
}
#if LANG_CXX11
inline void OVapiStopTimeUpdate::set_station_id(::std::string&& value) {
  set_has_station_id();
  station_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transit_realtime.OVapiStopTimeUpdate.station_id)
}
#endif
inline void OVapiStopTimeUpdate::set_station_id(const char* value) {
  set_has_station_id();
  station_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.OVapiStopTimeUpdate.station_id)
}
inline void OVapiStopTimeUpdate::set_station_id(const char* value, size_t size) {
  set_has_station_id();
  station_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.OVapiStopTimeUpdate.station_id)
}
inline ::std::string* OVapiStopTimeUpdate::mutable_station_id() {
  set_has_station_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.OVapiStopTimeUpdate.station_id)
  return station_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OVapiStopTimeUpdate::release_station_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.OVapiStopTimeUpdate.station_id)
  clear_has_station_id();
  return station_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OVapiStopTimeUpdate::set_allocated_station_id(::std::string* station_id) {
  if (station_id != NULL) {
    set_has_station_id();
  } else {
    clear_has_station_id();
  }
  station_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), station_id);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.OVapiStopTimeUpdate.station_id)
}

// -------------------------------------------------------------------

// OVapiVehicleDescriptor

// optional bool wheelchair_accessible = 1;
inline bool OVapiVehicleDescriptor::has_wheelchair_accessible() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OVapiVehicleDescriptor::set_has_wheelchair_accessible() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OVapiVehicleDescriptor::clear_has_wheelchair_accessible() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OVapiVehicleDescriptor::clear_wheelchair_accessible() {
  wheelchair_accessible_ = false;
  clear_has_wheelchair_accessible();
}
inline bool OVapiVehicleDescriptor::wheelchair_accessible() const {
  // @@protoc_insertion_point(field_get:transit_realtime.OVapiVehicleDescriptor.wheelchair_accessible)
  return wheelchair_accessible_;
}
inline void OVapiVehicleDescriptor::set_wheelchair_accessible(bool value) {
  set_has_wheelchair_accessible();
  wheelchair_accessible_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.OVapiVehicleDescriptor.wheelchair_accessible)
}

// optional string vehicle_type = 2;
inline bool OVapiVehicleDescriptor::has_vehicle_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OVapiVehicleDescriptor::set_has_vehicle_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OVapiVehicleDescriptor::clear_has_vehicle_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OVapiVehicleDescriptor::clear_vehicle_type() {
  vehicle_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vehicle_type();
}
inline const ::std::string& OVapiVehicleDescriptor::vehicle_type() const {
  // @@protoc_insertion_point(field_get:transit_realtime.OVapiVehicleDescriptor.vehicle_type)
  return vehicle_type_.GetNoArena();
}
inline void OVapiVehicleDescriptor::set_vehicle_type(const ::std::string& value) {
  set_has_vehicle_type();
  vehicle_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.OVapiVehicleDescriptor.vehicle_type)
}
#if LANG_CXX11
inline void OVapiVehicleDescriptor::set_vehicle_type(::std::string&& value) {
  set_has_vehicle_type();
  vehicle_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transit_realtime.OVapiVehicleDescriptor.vehicle_type)
}
#endif
inline void OVapiVehicleDescriptor::set_vehicle_type(const char* value) {
  set_has_vehicle_type();
  vehicle_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.OVapiVehicleDescriptor.vehicle_type)
}
inline void OVapiVehicleDescriptor::set_vehicle_type(const char* value, size_t size) {
  set_has_vehicle_type();
  vehicle_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.OVapiVehicleDescriptor.vehicle_type)
}
inline ::std::string* OVapiVehicleDescriptor::mutable_vehicle_type() {
  set_has_vehicle_type();
  // @@protoc_insertion_point(field_mutable:transit_realtime.OVapiVehicleDescriptor.vehicle_type)
  return vehicle_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OVapiVehicleDescriptor::release_vehicle_type() {
  // @@protoc_insertion_point(field_release:transit_realtime.OVapiVehicleDescriptor.vehicle_type)
  clear_has_vehicle_type();
  return vehicle_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OVapiVehicleDescriptor::set_allocated_vehicle_type(::std::string* vehicle_type) {
  if (vehicle_type != NULL) {
    set_has_vehicle_type();
  } else {
    clear_has_vehicle_type();
  }
  vehicle_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vehicle_type);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.OVapiVehicleDescriptor.vehicle_type)
}

// optional string vehicle_headsign = 3;
inline bool OVapiVehicleDescriptor::has_vehicle_headsign() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OVapiVehicleDescriptor::set_has_vehicle_headsign() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OVapiVehicleDescriptor::clear_has_vehicle_headsign() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OVapiVehicleDescriptor::clear_vehicle_headsign() {
  vehicle_headsign_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vehicle_headsign();
}
inline const ::std::string& OVapiVehicleDescriptor::vehicle_headsign() const {
  // @@protoc_insertion_point(field_get:transit_realtime.OVapiVehicleDescriptor.vehicle_headsign)
  return vehicle_headsign_.GetNoArena();
}
inline void OVapiVehicleDescriptor::set_vehicle_headsign(const ::std::string& value) {
  set_has_vehicle_headsign();
  vehicle_headsign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.OVapiVehicleDescriptor.vehicle_headsign)
}
#if LANG_CXX11
inline void OVapiVehicleDescriptor::set_vehicle_headsign(::std::string&& value) {
  set_has_vehicle_headsign();
  vehicle_headsign_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transit_realtime.OVapiVehicleDescriptor.vehicle_headsign)
}
#endif
inline void OVapiVehicleDescriptor::set_vehicle_headsign(const char* value) {
  set_has_vehicle_headsign();
  vehicle_headsign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.OVapiVehicleDescriptor.vehicle_headsign)
}
inline void OVapiVehicleDescriptor::set_vehicle_headsign(const char* value, size_t size) {
  set_has_vehicle_headsign();
  vehicle_headsign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.OVapiVehicleDescriptor.vehicle_headsign)
}
inline ::std::string* OVapiVehicleDescriptor::mutable_vehicle_headsign() {
  set_has_vehicle_headsign();
  // @@protoc_insertion_point(field_mutable:transit_realtime.OVapiVehicleDescriptor.vehicle_headsign)
  return vehicle_headsign_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OVapiVehicleDescriptor::release_vehicle_headsign() {
  // @@protoc_insertion_point(field_release:transit_realtime.OVapiVehicleDescriptor.vehicle_headsign)
  clear_has_vehicle_headsign();
  return vehicle_headsign_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OVapiVehicleDescriptor::set_allocated_vehicle_headsign(::std::string* vehicle_headsign) {
  if (vehicle_headsign != NULL) {
    set_has_vehicle_headsign();
  } else {
    clear_has_vehicle_headsign();
  }
  vehicle_headsign_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vehicle_headsign);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.OVapiVehicleDescriptor.vehicle_headsign)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace transit_realtime

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gtfs_2drealtime_2dOVapi_2eproto__INCLUDED
